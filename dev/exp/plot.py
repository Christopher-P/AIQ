### Used to plot experimental results from run.py
import csv
import numpy as np
from scipy.stats import pearsonr
from numpy import mean
import matplotlib.pyplot as plt

import math
def load_file(filename):
    data = []
    with open('data_bak/' + filename, newline='') as csvfile:
        spamreader = csv.reader(csvfile, delimiter='|', quotechar=' ')
        for row in spamreader:
            data.append((row[0], row[1], float(row[2])))

    return data

def gen_nice_results(keys, res):
    with open('nice results.csv', 'w', newline='') as csvfile:
        spamwriter = csv.writer(csvfile, delimiter=',')
        fieldnames = list(keys.keys())
        spamwriter.writerow(fieldnames)
        for ind, val in enumerate(res):
            name = list(keys.keys())[ind]
            spamwriter.writerow([name, *val])


# Plot results in a heatmap
def cross_table(data):
    counter = 0
    keys = {}
    for val in data:
        if val[0] not in keys:
            keys[val[0]] = counter
            counter += 1
        if val[1] not in keys:
            keys[val[1]] = counter
            counter += 1

    res = np.zeros([len(keys),len(keys)])

    for val in data:
        res[keys[val[0]]][keys[val[1]]] = val[2]

    gen_nice_results(keys,res)
    #print(res)
    return res

# Plot the cross tabled data
def plott(res, name, ax):

    names = ["CartPole-v0", "CartPole-v1", "Acrobot-v1",
            "MountainCar-v0", "Roulette-v0","FrozenLake-v0",
             "CliffWalking-v0","NChain-v0","FrozenLake8x8-v0", "Taxi-v2"]
    # new plot
    #fig, ax = plt.subplots(figsize=(14, 10))
    im = ax.imshow(res)
    print(res.shape)

    # We want to show all ticks...
    ax.set_xticks(np.arange(len(res)))
    ax.set_yticks(np.arange(len(res)))
    # ... and label them with the respective list entries
    ax.set_xticklabels(names)
    ax.set_yticklabels(names)

    # Rotate the tick labels and set their alignment.
    plt.setp(ax.get_xticklabels(), rotation=45, ha="right",
             rotation_mode="anchor")
    # Rotate the tick labels and set their alignment.
    plt.setp(ax.get_yticklabels(), rotation=45, ha="right",
             rotation_mode="anchor")

    # Loop over data dimensions and create text annotations.
    for i in range(len(res)):
        for j in range(len(res)):
            text = ax.text(j, i, round(res[i, j],2), size=4,
                           ha="center", va="center", color="w")

    ax.set_title(name)
    #fig.tight_layout()
    #plt.savefig('HeatMap.png', dpi=400)
    #plt.show()

    return ax

# Load results generated by AIQ sim measure
def load_AIQ():
    data = []

    with open('d=1.csv', newline='') as csvfile:
        spamreader = csv.reader(csvfile, delimiter=',', quotechar='|')
        for row in spamreader:
            data.append(row)

    A = None
    B = None
    name1 = None
    name2 = None
    counter = 0
    info = []

    for ind, val in enumerate(data):
        if counter >= 3:
            counter = 0
        
        if counter == 0:
            name1 = val[0]
            A = float(val[2])

        elif counter == 1:
            name2 = val[0]
            B = float(val[2])

        elif counter == 2:
            Vmax = max(A,B)
            Vmin = min(A,B)
            V = float(val[2])
            if A == B:
                S = 0.5
            else:
                S = abs(abs(Vmax - V) - abs(Vmin - V) ) / abs( A  - B )
            info.append((name1, name2, S))         

        else:
            print('error')
            exit()

        counter += 1
        continue
    return info


files = ['Reward.csv','Ratio.csv', 'JumpStart.csv', 'Asymptotic.csv']

# Get sim measure data
info = load_AIQ()
info = cross_table(info)
# this one entry is out of whach
info[7,8] = info[7,5]
info[7,5] = 0.0
## Fill out table (remove 0.0 values)
for i in range(10):
    for j in range(10):
        info[j,i] = info[i,j]

fig, axs = plt.subplots(4, 2,figsize=(12,20))

# Scale data now
for ind,name in enumerate(files):
    # Load data
    data = load_file(name)
    
    # Cross table the data
    ct = cross_table(data)
    ct = ct.T
    pearson = np.corrcoef(ct,info)

    # This is a 2x2 coorelation matrix, so get one corner
    top_right = np.asarray([pearson[i][10:] for i in range(10)]) 
    t = 0
    for i in range(10):
        t = t + top_right[i][i]
        #print(top_right[i][i])

    sim = [1.0,1.0,0.1315258794532825,
    0.025197595082077928,
    0.5488069414316703,
    0.4992884732669241,
    0.8160427807486632,
    0.391907514450867
    ,0.10085831313990765,
    0.20373573158076802]

    TL = [0.00042378420033432895,
    0.0010126680668700178,
    -0.11431468619321938,
    -0.11431468619321938,
    0.20400393089420732,
    -0.09639627216348244,
    0.22347143276210657,
    0.30853014139298746,
    -0.11273988304361308,
    0.08070703507013621]

    # Do math here
    #upper = 10*np.dot(sim,TL)-sum(TL)*sum(sim)
    #lower = math.sqrt((10*sum([i**2 for i in sim]) - sum(sim)**2) * (10*sum([i**2 for i in TL]) - sum(TL)**2))
    #r = upper/lower
    #print(r)

    print(t/10)
    #print(np.corrcoef(sim,TL))
    #print(np.corrcoef(info[0],ct.T[0]))
    #exit()
    continue

    #print(top_right.sum()/100)
    #continue

    # Plot the data
    plott(ct, name[0:-4] + " raw", axs[ind,0])
    plott(top_right, name[0:-4] + " coorelation", axs[ind,1])

   
fig.tight_layout()
#plt.show() 
plt.savefig('G.png', dpi=400)

    





